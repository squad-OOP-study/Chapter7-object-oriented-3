# 객체 지향과 디자인 패턴 - 3번째

## 파사드 패턴(외관 패턴)
- Facade 패턴은 "하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스를 정의한다"
- 복잡한 서브시스템을 감춰 주는 상위 수준의 인터페이스를 제공할 때, 이용하는 디자인 패턴
- Facade (외관)는 "건물의 정면"을 의미한다.

### 구조
![UML_DP_Façade](https://user-images.githubusercontent.com/95393311/159126838-1e66b99e-3b4c-4aa8-bdd9-5a9075d26794.png)
- 퍼사드 : 퍼사드 클래스는 패키지 1,2,3 및 그림에 나오지 않은 그 밖의 응용 프로그램 코드와 상호 동작한다.
- 클라이언트 : 패키지 내의 리소스들을 접근하기 위해 퍼사드 클래스를 쓰는 객체들이다.
- 패키지(서브시스템) : 소프트웨어 라이브러리 / API 집합이다. 퍼사드 클래스를 통해 접근된다.

### 예제
```
/* subsystem */

class CPU {
    fun processData() {
        println("데이터를 프로세싱 중")
    }
}

class HardDrive {
    fun read() {
        println("데이터를 읽어오는 중")
    }
}

class Memory {
    fun load() {
        println("데이터를 불러오는 중")
    }
}

/* Facade */

class ComputerFacade {
    private val processor = CPU()
    private val ram = Memory()
    private val hd = HardDrive()

    fun run() {
        processor.processData()
        ram.load()
        hd.read()
    }
} /* Client */

fun main() {
    val computer = ComputerFacade()
    computer.run()
}

//결과
데이터를 프로세싱 중
데이터를 불러오는 중
데이터를 읽어오는 중
```

### 장점과 특징
- 코드 중복 문제 해결
- 클라이언트와 서브시스템 간의 직접적인 의존이 제거되어, 서브시스템이 변경되더라도 그 여파는 파사드 객체에게만 한정됨
- 서브 시스템의 상세한 구현을 캡슐화할 수 있다
- 파사드 객체가 여러 개라면 파사드 클래스를 추상화 및 인터페이스화하여 클라이언트의 변경없이 서브 시스템 자체를 변경할 수 있음 (다른 서브 시스템에 접근할 수 있음)
- 다수의 클라이언트의 공통된 기능은 파사드 객체 또는 인터페이스를 통해 서브 시스템에 간접적으로 접근할 수 있으며, 세밀한 제어 또는 특정 기능이 필요하면 직접 서브 시스템에 접근하는 방식도 가능


## 추상 팩토리 패턴
- 팩토리 패턴이란?
    - 객체 생성에 대한 책임을 팩토리 클래스에 위임하여, 팩토리 클래스에서 입력된 조건에 맞는 객체를 생성하는 디자인 패턴
- 추상 팩토리 패턴이란?
    - 팩토리 패턴들을 추상화하여 조건에 맞는 팩토리 클래스를 동작하여 조건에 맞는 객체를 생성하는 디자인 패턴
    - 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공
    - 쉽게 말해, 팩토리 패턴에서 더 캡슐화된 방식

### 예제
![1](https://user-images.githubusercontent.com/95393311/159130870-b9d2a3df-68f8-4629-898d-199bf34efb1f.jpg)
- Stage 클래스에서 인자(레벨)를 통해 구현할 팩토리 클래스를 정하여 해당 팩토리 클래스에서 객체를 생성하도록 위임함
- EnemyFactory 클래스의 메서드를 통해 구현 팩토리 클래스를 생성했으나, DI (생성자)를 통해서 Stage 클래스를 생성할 때, 구현 팩토리 클래스를 바로 생성할 수도 있음
    - 이러면 자바에서는 EnemyFactory 클래스를 추상 클래스가 아니라 인터페이스로 전환할 수 있음
    - 하지만 코틀린에서는 인터페이스에서도 메서드를 구현할 수 있어서 처음부터 인터페이스로 만들어도 됨
- 또 다른 예로는 자바의 JDBC API 구조가 있음

### 장점
- 클라이언트에 영향을 주지 않으면서 사용할 객체(제품)군을 교체할 수 있음

#### 프로토 타입 방식의 팩토리
- 팩토리가 생성하는 객체가 늘 동일한 상태를 갖는다면, 이 방식을 활용할 수 있음
- 팩토리 클래스에서 생성할 객체를 미리 생성하여 가지고 있음 (프로토타입처럼)
- 객체를 생성하라는 요청을 받으면 미리 가지고 있는 객체를 복제하여 반환하여 전달
- 장점
    - 추상 팩토리 타입과 구현 팩토리 클래스를 따로 만들 필요가 없음
- 단점
    - 객체를 생성하는 규칙이 복잡하면 적용할 수 없음


## 컴포지트 패턴
- 컴포지트란?
    - OOP 에서 컴포지트(Composite) 는 하나 이상의 유사한 객체를 구성으로 설계된 객체로 모두 유사한 기능을 나타낸다.
    - 출처: [마이구미의 HelloWorld](https://mygumi.tistory.com/343)
- 컴포지트 패턴(Composite Pattern)
    - 간단하게 말해 단일 객체(Single Instance)든 객체들의 집합(Group of Instance)든 같은 방법으로 취급하는 것입니다.
    - 즉, 개별적인 객체들과 객체들의 집합간의 처리 방법의 차이가 없을 경우 사용하면 됨.
    - 여기서 컴포지트(Composite)의 의미는 일부 또는 그룹을 표현하는 객체들을 트리 구조(Tree Structures)로 구성한다는 것.
    - [출처](https://jdm.kr/blog/228)
- 코드 증복과 높은 복잡도 문제를 해결하기 위해 전체 - 부분을 구성하는 클래스가 동일한 인터페이스를 가지도록 하는 디자인 패턴

### 구조
![2](https://user-images.githubusercontent.com/95393311/159130872-f07b573a-126a-472a-a318-30b26987e167.jpg)

- Component : 모든 component 들을 위한 추상화된 개념으로써, "Leaf(단말)" 와 "Composite" 클래스의 인터페이스이다.
- Leaf : "Component" 인터페이스를 구현하고, 구체 클래스를 나타낸다.
- Composite :
    - 컴포넌트 그룹 관리: "Component"  인터페이스를 구현하고, 구현되는 자식(Leaf or Composite) 들을 가지고, 이러한 자식들을 관리하기 위한 메소드(addDevice, removeDevice...)를 구현한다.
    - 컴포지트에 기능 실행을 요청하면, 컴포지트는 이를 포함하고 있는 컴포넌트들에게 기능 실행을 위임함

### 장점
- 클라이언트(PowerController)는 전체(컴포지트)냐 부분(단말)이냐에 상관없이 단일 인터페이스로 기능을 실행할 수 있음
- 컴포지트도 컴포넌트이기 때문에 컴포지트에 다른 컴포지트를 등록하여 활용할 수 있음

### 고려 사항
- 컴포넌트를 관리하는 기능을 어디에서 구현할지 고려해야 함
- 위에서처럼 컴포넌트 그룹을 관리하는 기능을 컴포지트에서 구현할 수 있음
    - 컴포넌트를 컴포지트에 추가하기 위해서는 클라이언트가 컴포지트 타입에 직접 접근해야 함
  ```
  val group = DeviceGroup()
  groupd.addDevice(device1)
  groupd.addDevice(device2)
  ```

- 컴포넌트 그룹을 관리하는 기능을 컴포넌트 인터페이스에서 구현할 수도 있음
    - 이 경우, 컴포지트가 아닐 때 add 및 remove 기능 등 컴포넌트를 관리하는 기능이 작동되지 않도록 예외 처리를 해야함
    - 더 나은 방법으로는 컴포지트인지 아닌지 판단(Boolean 값을 반환)하는 메서드를 구현하여 이를 통해 컴포지트에 등록할 수 있도록 제한할 수 있음
        - 이 방법으로 단순히 컴포넌트를 관리하는 기능에서 나아가 특정 객체만 관리할 수 있도록 제한할 수도 있음


## 널 객체 패턴
- null을 리턴하지 않고 null을 대신할 객체를 리턴함으로써 null 검사 코드를 없앨 수 있도록 함

### 구현
- null 대신 사용할 클래스를 구현함. 이 클래스는 상위 타입을 상속받으며, 아무 기능도 수행하지 않음
- null을 리턴하는 대신, null을 대체할 클래스의 객체를 리턴함

### 장점
- null 검사 코드 누락에 따른 NPE 문제를 해결
- null 검사 코드를 작성할 필요가 없으니 코드가 간결해지고 이는 곧 코드 가독성을 높여줌. 이를 통해 코드 수정을 쉽게 만들어줌

### 사견
- 코틀린에서는 nullable 타입을 지정할 수 있음
- 안드로이드 스튜디오, 인텔리제이 등 IDE에서 nullable 타입에 대한 누락을 방지시켜줌
    - null 검사가 누락할 가능성 낮음
- 코드가 복잡해짐
  - 스코프 함수와 엘비스 연산자를 통해 코드를 간결하게 작성할 수 있음
  - null을 대체할 클래스를 생성해서 구조가 복잡해질 수 있음
- 만약 자바를 함께 사용하는 프로젝트라면 사용할 것 같음. 또는 자바와의 호환성을 위해 사용할 것 같음